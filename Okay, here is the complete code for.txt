Отличная идея! Хранение дополнительной информации о пользователе локально в Room и возможность редактирования (включая аватар) — это хорошее расширение функционала.

Вот план и этапы реализации:

План:

Создать UserEntity: Сущность для хранения данных пользователя в Room (userId от Firebase, отображаемое имя, путь к аватару/данные аватара).

Создать UserDao: Интерфейс для доступа к данным пользователя.

Обновить AppDatabase: Добавить UserEntity и UserDao. Написать миграцию.

Обновить PasswordRepository: Добавить методы для работы с UserDao.

Обновить PasswordViewModel: Добавить LiveData для профиля пользователя и методы для его получения/обновления.

Создать Layout для редактирования профиля: Либо новый фрагмент/диалог (EditProfileFragment/EditProfileDialog), либо добавить элементы редактирования прямо в ProfileFragment (менее удобно).

Реализовать выбор/сохранение аватара: Использовать Activity Result API для выбора изображения из галереи, сохранить его (либо как файл в приватном хранилище приложения, либо как ByteArray в БД) и обновить UserEntity.

Обновить ProfileFragment:

Отображать данные пользователя из UserEntity (полученные через ViewModel).

Показать кнопку "Редактировать профиль".

При нажатии кнопки — переходить на экран/диалог редактирования.

Загружать и отображать аватар (например, с помощью Glide).

Реализовать EditProfileFragment (или диалог):

Загружать текущие данные пользователя.

Предоставлять поля для редактирования имени.

Предоставлять кнопку/ImageView для смены аватара (запускает выбор изображения).

Реализовать сохранение изменений через ViewModel/Repository.

Обработка при первом входе/регистрации: При успешном входе/регистрации создавать начальную запись UserEntity в Room, используя userId и email из Firebase.

Этап 1: UserEntity.kt

Создаем сущность. userId будет первичным ключом и будет совпадать с uid из Firebase Auth.

package com.example.tutor.db // Помещаем в пакет db

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "user_profile")
data class UserEntity(
    @PrimaryKey
    val userId: String, // Firebase User UID

    var displayName: String?, // Отображаемое имя, может быть null

    var email: String?, // Email (можно дублировать из Auth для удобства)

    // Вариант 1: Хранить путь к файлу аватара
    var avatarPath: String? = null

    // Вариант 2: Хранить аватар как ByteArray (BLOB) - подходит для небольших изображений
    // @ColumnInfo(typeAffinity = ColumnInfo.BLOB)
    // var avatarData: ByteArray? = null

    // Можно добавить и другие поля: дата создания профиля и т.д.
    // val profileCreatedAt: Long = System.currentTimeMillis()
) {
    // Не забываем equals/hashCode, если будем хранить ByteArray
    /*
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as UserEntity
        if (userId != other.userId) return false
        if (displayName != other.displayName) return false
        if (email != other.email) return false
        // Сравнение пути или данных аватара
        if (avatarPath != other.avatarPath) return false
        // if (avatarData != null) {
        //     if (other.avatarData == null) return false
        //     if (!avatarData.contentEquals(other.avatarData)) return false
        // } else if (other.avatarData != null) return false
        return true
    }

    override fun hashCode(): Int {
        var result = userId.hashCode()
        result = 31 * result + (displayName?.hashCode() ?: 0)
        result = 31 * result + (email?.hashCode() ?: 0)
        result = 31 * result + (avatarPath?.hashCode() ?: 0)
        // result = 31 * result + (avatarData?.contentHashCode() ?: 0)
        return result
    }
    */
}


(Я выбрал вариант с avatarPath, он часто предпочтительнее для управления файлами. Если выберете avatarData, раскомментируйте соответствующие строки и equals/hashCode)

Этап 2: UserDao.kt

package com.example.tutor.db

import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update

@Dao
interface UserDao {

    // Вставить или заменить профиль (если пользователь уже есть)
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdateUser(user: UserEntity)

    // Получить профиль пользователя по ID (Firebase UID)
    // Возвращает LiveData для наблюдения в UI
    @Query("SELECT * FROM user_profile WHERE userId = :userId LIMIT 1")
    fun getUserById(userId: String): LiveData<UserEntity?> // Nullable, т.к. профиля может еще не быть

    // Получить профиль пользователя (не LiveData, для однократных операций)
    @Query("SELECT * FROM user_profile WHERE userId = :userId LIMIT 1")
    suspend fun getUserByIdOnce(userId: String): UserEntity?

    // Обновить только отображаемое имя
    @Query("UPDATE user_profile SET displayName = :displayName WHERE userId = :userId")
    suspend fun updateDisplayName(userId: String, displayName: String?)

    // Обновить только путь к аватару
    @Query("UPDATE user_profile SET avatarPath = :avatarPath WHERE userId = :userId")
    suspend fun updateAvatarPath(userId: String, avatarPath: String?)

    // Или общая функция обновления (если UserEntity содержит только нужные поля)
    @Update
    suspend fun updateUser(user: UserEntity)

    // Опционально: Удалить профиль (при удалении аккаунта Firebase)
    @Query("DELETE FROM user_profile WHERE userId = :userId")
    suspend fun deleteUser(userId: String)
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Этап 3: Обновить AppDatabase.kt

Добавить UserEntity в список entities.

Увеличить version базы данных (например, с 5 до 6).

Добавить абстрактную функцию для UserDao.

Написать миграцию MIGRATION_5_6.

package com.example.tutor.db

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import android.util.Log

// Добавляем UserEntity, увеличиваем версию до 6
@Database(entities = [PasswordEntity::class, SecurityLogEvent::class, UserEntity::class], version = 6, exportSchema = false)
abstract class AppDatabase : RoomDatabase() {
    abstract fun passwordDao(): PasswordDao
    abstract fun securityLogDao(): SecurityLogDao
    abstract fun userDao(): UserDao // <-- Добавляем UserDao

    companion object {
        @Volatile private var INSTANCE: AppDatabase? = null

        // ... (MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5 как раньше) ...
        val MIGRATION_1_2 = object : Migration(1, 2) { /* ... */ }
        val MIGRATION_2_3 = object : Migration(2, 3) { /* ... */ }
        val MIGRATION_3_4 = object : Migration(3, 4) { /* ... */ }
        val MIGRATION_4_5 = object : Migration(4, 5) { /* ... */ }

        // --- Миграция 5 -> 6: Добавление таблицы user_profile ---
        val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(db: SupportSQLiteDatabase) {
                Log.i("DB_MIGRATION", "Миграция базы данных с версии 5 на 6 - Добавление таблицы user_profile")
                // Создаем таблицу user_profile
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `user_profile` (
                        `userId` TEXT NOT NULL PRIMARY KEY,
                        `displayName` TEXT,
                        `email` TEXT,
                        `avatarPath` TEXT
                    )
                """.trimIndent())
                // Можно добавить индексы при необходимости, например, по email
                // db.execSQL("CREATE INDEX IF NOT EXISTS `index_user_profile_email` ON `user_profile` (`email`)")
            }
        }
        // --- КОНЕЦ Миграции 5 -> 6 ---

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "password-db"
                )
                    // Добавляем все миграции, включая новую
                    .addMigrations(
                        MIGRATION_1_2,
                        MIGRATION_2_3,
                        MIGRATION_3_4,
                        MIGRATION_4_5,
                        MIGRATION_5_6 // <-- Новая миграция
                    )
                    // .fallbackToDestructiveMigration() // Используйте при разработке
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Этап 4: Обновить PasswordRepository.kt

Внедрить UserDao.

Добавить методы для получения и обновления пользователя.

package com.example.tutor.viewmodels // Или ваш пакет репозитория

import androidx.lifecycle.LiveData
import com.example.tutor.db.* // Импорт всех сущностей и DAO из db
import com.example.tutor.util.SecurityEventTypes
import android.util.Log
import java.lang.Exception

class PasswordRepository(
    private val passwordDao: PasswordDao,
    private val securityLogDao: SecurityLogDao,
    private val userDao: UserDao // <-- Внедряем UserDao
) {

    // --- LiveData для паролей и логов (как раньше) ---
    val allPasswords: LiveData<List<PasswordEntity>> = passwordDao.getAllPasswords()
    val passwordCountsByCategory: LiveData<Map<String, Int>> = passwordDao.getPasswordCountsByCategory()
    val trashItems: LiveData<List<PasswordEntity>> = passwordDao.getTrashItems()
    val securityLogEvents: LiveData<List<SecurityLogEvent>> = securityLogDao.getAllEvents()

    // --- Методы для паролей и логов (как раньше) ---
    fun getPasswordsByCategory(category: String): LiveData<List<PasswordEntity>> { /* ... */ }
    suspend fun insert(password: PasswordEntity) { /* ... */ }
    suspend fun update(password: PasswordEntity) { /* ... */ }
    suspend fun softDeleteById(id: Int) { /* ... */ }
    suspend fun restoreById(id: Int) { /* ... */ }
    suspend fun deletePermanentlyById(id: Int) { /* ... */ }
    suspend fun emptyTrash() { /* ... */ }
    suspend fun updateFavicon(id: Int, url: String?, favicon: ByteArray?) { /* ... */ }
    suspend fun logSecurityEvent(eventType: String, description: String?) { /* ... */ }
    suspend fun clearSecurityLog() { /* ... */ }

    // --- !!! НОВЫЕ МЕТОДЫ для пользователя !!! ---

    /**
     * Получает LiveData профиля пользователя по ID.
     */
    fun getUserProfile(userId: String): LiveData<UserEntity?> {
        return userDao.getUserById(userId)
    }

    /**
     * Получает профиль пользователя однократно (не LiveData).
     */
    suspend fun getUserProfileOnce(userId: String): UserEntity? {
         return try {
             userDao.getUserByIdOnce(userId)
         } catch (e: Exception) {
              Log.e("PasswordRepository", "Ошибка получения профиля пользователя $userId", e)
              null
         }
    }


    /**
     * Вставляет или обновляет профиль пользователя.
     */
    suspend fun saveUserProfile(user: UserEntity) {
        try {
            userDao.insertOrUpdateUser(user)
            Log.d("PasswordRepository", "Профиль пользователя ${user.userId} сохранен.")
        } catch (e: Exception) {
             Log.e("PasswordRepository", "Ошибка сохранения профиля пользователя ${user.userId}", e)
        }
    }

    /**
     * Обновляет только отображаемое имя пользователя.
     */
    suspend fun updateUserDisplayName(userId: String, displayName: String?) {
         try {
             userDao.updateDisplayName(userId, displayName)
             Log.d("PasswordRepository", "Отображаемое имя пользователя $userId обновлено.")
         } catch (e: Exception) {
              Log.e("PasswordRepository", "Ошибка обновления отображаемого имени пользователя $userId", e)
         }
    }

     /**
     * Обновляет только путь к аватару пользователя.
     */
    suspend fun updateAvatarPath(userId: String, avatarPath: String?) {
         try {
             userDao.updateAvatarPath(userId, avatarPath)
             Log.d("PasswordRepository", "Путь к аватару пользователя $userId обновлен.")
         } catch (e: Exception) {
              Log.e("PasswordRepository", "Ошибка обновления пути к аватару пользователя $userId", e)
         }
    }

    // --- !!! КОНЕЦ НОВЫХ МЕТОДОВ !!! ---
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

(Сократил код существующих методов для краткости)

Следующие шаги:

Обновить PasswordViewModel.

Реализовать логику создания UserEntity при входе/регистрации.

Создать UI для редактирования.

Обновить ProfileFragment для отображения данных.

Продолжим?

Отлично, продолжаем!

Этап 5: Обновить PasswordViewModel.kt

Добавим LiveData для профиля пользователя и методы для взаимодействия с ним через репозиторий.

package com.example.tutor.viewmodels

import android.app.Application
import android.graphics.BitmapFactory
import android.util.Log
import androidx.lifecycle.*
import com.example.tutor.db.* // Импорт всех сущностей и DAO
import com.example.tutor.security.CryptoManager
import com.example.tutor.util.SecurityEventTypes
import com.google.firebase.auth.FirebaseAuth // Импорт для получения текущего пользователя
import com.google.firebase.auth.ktx.auth
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.*
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File // Для работы с файлами аватара
import java.io.FileOutputStream
import java.io.IOException
import java.net.MalformedURLException
import java.net.URL
import java.util.concurrent.TimeUnit
import java.lang.Exception

class PasswordViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: PasswordRepository
    private val auth: FirebaseAuth = Firebase.auth // Доступ к Firebase Auth

    // LiveData для паролей, логов и т.д. (как раньше)
    val passwordCountsByCategory: LiveData<Map<String, Int>>
    val displayedPasswords: LiveData<List<PasswordEntity>>
    val displayedTrashItems: LiveData<List<PasswordEntity>>
    val securityLog: LiveData<List<SecurityLogEvent>>
    val currentCategoryFilter: LiveData<String>
    private val _currentCategoryFilter = MutableLiveData("All")
    val categories = listOf("All", "Social", "Gaming", "Work", "Finance", "Other")
    // ... (и другие LiveData и инициализации, как раньше)

    // --- !!! ДОБАВЛЕНО: LiveData для профиля пользователя !!! ---
    private val _userProfile = MediatorLiveData<UserEntity?>()
    val userProfile: LiveData<UserEntity?> = _userProfile
    // --- !!! КОНЕЦ ДОБАВЛЕНИЯ !!! ---

    // OkHttp клиент
    private val httpClient: OkHttpClient = OkHttpClient.Builder()
        .connectTimeout(5, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .build()

    init {
        Log.d("PasswordViewModel", "Инициализация...")
        val db = AppDatabase.getDatabase(application)
        val passwordDao = db.passwordDao()
        val securityLogDao = db.securityLogDao()
        val userDao = db.userDao() // <-- Получаем UserDao
        // Передаем все три DAO в репозиторий
        repository = PasswordRepository(passwordDao, securityLogDao, userDao) // <-- Обновлено

        // Инициализация LiveData (как раньше)
        passwordCountsByCategory = repository.passwordCountsByCategory
        displayedPasswords = MediatorLiveData<List<PasswordEntity>>().apply { /* ... setupMediator sources ... */ }
        _displayedTrashItems = MutableLiveData()
        securityLog = repository.securityLogEvents
        currentCategoryFilter = _currentCategoryFilter
        // ... (allPasswordsSource, trashItemsSource и т.д.)

        // --- !!! ДОБАВЛЕНО: Наблюдение за профилем пользователя !!! ---
        auth.currentUser?.uid?.let { userId ->
            // Добавляем источник LiveData из репозитория
            _userProfile.addSource(repository.getUserProfile(userId)) { user ->
                _userProfile.value = user
                 // Проверяем, существует ли профиль при первом наблюдении
                 if (user == null && _userProfile.value == null) { // Добавил проверку _userProfile.value == null, чтобы не создавать повторно
                     Log.i("PasswordViewModel", "Профиль для пользователя $userId не найден, создаем...")
                     createInitialUserProfile(userId)
                 } else {
                     Log.d("PasswordViewModel", "Профиль пользователя $userId загружен/обновлен.")
                 }
            }
        } ?: Log.e("PasswordViewModel", "Текущий пользователь Firebase null при инициализации ViewModel!")
        // --- !!! КОНЕЦ ДОБАВЛЕНИЯ !!! ---

        setupMediator() // Настраиваем MediatorLiveData для паролей
        observeTrashItems() // Наблюдаем за корзиной
        Log.d("PasswordViewModel", "Инициализация завершена.")
    }

    // --- !!! ДОБАВЛЕНО: Метод для создания начального профиля !!! ---
    private fun createInitialUserProfile(userId: String) {
        viewModelScope.launch(Dispatchers.IO) {
            val currentUser = auth.currentUser // Получаем текущего пользователя Firebase
            if (currentUser != null && currentUser.uid == userId) {
                val existingProfile = repository.getUserProfileOnce(userId) // Проверяем еще раз на всякий случай
                if (existingProfile == null) {
                    val newUser = UserEntity(
                        userId = userId,
                        displayName = currentUser.displayName, // Используем имя из Firebase, если есть
                        email = currentUser.email,
                        avatarPath = null // Изначально без аватара
                    )
                    repository.saveUserProfile(newUser)
                    Log.i("PasswordViewModel", "Создан начальный профиль для пользователя $userId")
                } else {
                     Log.w("PasswordViewModel", "Попытка создать профиль для $userId, но он уже существует.")
                }
            } else {
                 Log.e("PasswordViewModel", "Не удалось получить данные пользователя Firebase для создания профиля $userId")
            }
        }
    }

    // --- !!! ДОБАВЛЕНО: Методы для обновления профиля !!! ---
    fun updateUserProfile(displayName: String?, avatarUri: android.net.Uri?) {
        val currentUserId = auth.currentUser?.uid ?: return Unit.also {
             Log.e("PasswordViewModel", "Невозможно обновить профиль: пользователь не авторизован.")
        }
        val currentProfile = _userProfile.value // Берем текущее значение

        viewModelScope.launch(Dispatchers.IO) {
             var newAvatarPath: String? = currentProfile?.avatarPath // Сохраняем старый путь по умолчанию

             // 1. Обработка нового аватара (если выбран)
             if (avatarUri != null) {
                 newAvatarPath = saveAvatarToFile(avatarUri, currentUserId)
                 if (newAvatarPath == null) {
                      Log.e("PasswordViewModel", "Не удалось сохранить новый аватар.")
                      // TODO: Показать ошибку пользователю? Пока просто не обновляем путь.
                      newAvatarPath = currentProfile?.avatarPath // Возвращаем старый путь в случае ошибки
                 } else {
                     // Удаляем старый файл аватара, если он был и путь изменился
                     if (!currentProfile?.avatarPath.isNullOrEmpty() && currentProfile?.avatarPath != newAvatarPath) {
                         deleteOldAvatar(currentProfile?.avatarPath)
                     }
                 }
             }

             // 2. Создание или обновление UserEntity
            val updatedProfile = currentProfile?.copy(
                displayName = displayName,
                avatarPath = newAvatarPath,
                // Обновляем email на всякий случай, если он мог измениться в Firebase
                email = auth.currentUser?.email
            ) ?: UserEntity( // Создаем новый, если вдруг профиля не было (маловероятно здесь)
                 userId = currentUserId,
                 displayName = displayName,
                 email = auth.currentUser?.email,
                 avatarPath = newAvatarPath
             )

             // 3. Сохранение в репозитории
             repository.saveUserProfile(updatedProfile)
             Log.i("PasswordViewModel", "Профиль пользователя $currentUserId обновлен.")
             // LiveData _userProfile обновится автоматически благодаря наблюдению
        }
    }

    // Вспомогательный метод для сохранения аватара в приватное хранилище
    private suspend fun saveAvatarToFile(sourceUri: android.net.Uri, userId: String): String? = withContext(Dispatchers.IO) {
        val context = getApplication<Application>().applicationContext
        val inputStream = context.contentResolver.openInputStream(sourceUri) ?: return@withContext null
        // Создаем уникальное имя файла, например, на основе userId
        val fileName = "avatar_$userId.jpg"
        // Получаем приватную директорию для файлов приложения
        val outputDir = context.filesDir // или context.getExternalFilesDir(null) если нужно внешнее
        val outputFile = File(outputDir, fileName)

        try {
            FileOutputStream(outputFile).use { outputStream ->
                // Копируем данные из InputStream в OutputStream
                // Опционально: сжимаем изображение перед сохранением
                 val bitmap = BitmapFactory.decodeStream(inputStream)
                 bitmap?.compress(android.graphics.Bitmap.CompressFormat.JPEG, 85, outputStream) // Сжатие 85%
                 // или просто inputStream.copyTo(outputStream) для копирования без сжатия/изменения
            }
             Log.d("PasswordViewModel", "Аватар сохранен в: ${outputFile.absolutePath}")
            return@withContext outputFile.absolutePath // Возвращаем путь к сохраненному файлу
        } catch (e: IOException) {
            Log.e("PasswordViewModel", "Ошибка сохранения файла аватара", e)
            outputFile.delete() // Удаляем частично созданный файл при ошибке
            return@withContext null
        } finally {
            inputStream.close()
        }
    }

    // Вспомогательный метод для удаления старого файла аватара
    private fun deleteOldAvatar(filePath: String?) {
        if (filePath.isNullOrEmpty()) return
        try {
             val file = File(filePath)
             if (file.exists()) {
                 if (file.delete()) {
                     Log.d("PasswordViewModel", "Старый файл аватара удален: $filePath")
                 } else {
                     Log.w("PasswordViewModel", "Не удалось удалить старый файл аватара: $filePath")
                 }
             }
        } catch (e: SecurityException) {
             Log.e("PasswordViewModel", "Ошибка доступа при удалении старого аватара: $filePath", e)
        } catch (e: Exception) {
            Log.e("PasswordViewModel", "Общая ошибка при удалении старого аватара: $filePath", e)
        }
    }

    // --- Остальные методы ViewModel (как раньше) ---
    // setupMediator(), observeTrashItems(), updateDataSource(), decryptAndSetPasswords(),
    // setCategoryFilter(), addPassword(), softDeletePassword(), restorePassword(),
    // deletePasswordPermanently(), emptyTrash(), clearSecurityLog(),
    // fetchAndCacheFaviconIfNeeded(), downloadFavicon(), ensureValidUrl(), onCleared()
    // ... (Весь остальной код ViewModel без изменений) ...

    private fun setupMediator() { /* ... */ }
    private fun observeTrashItems() { /* ... */ }
    private fun updateDataSource(category: String) { /* ... */ }
    private fun decryptAndSetPasswords(encryptedList: List<PasswordEntity>?, targetLiveData: MutableLiveData<List<PasswordEntity>>) { /* ... */ }
    fun setCategoryFilter(category: String) { /* ... */ }
    fun addPassword(title: String, username: String, passwordToEncrypt: String, category: String, websiteUrl: String?) { /* ... с логированием ... */ }
    fun softDeletePassword(id: Int) { /* ... с логированием ... */ }
    fun restorePassword(id: Int) { /* ... с логированием ... */ }
    fun deletePasswordPermanently(id: Int) { /* ... с логированием ... */ }
    fun emptyTrash() { /* ... с логированием ... */ }
    fun clearSecurityLog() { /* ... с логированием ... */ }
    fun fetchAndCacheFaviconIfNeeded(passwordEntity: PasswordEntity) { /* ... */ }
    private suspend fun downloadFavicon(baseUrl: String): ByteArray? { /* ... */ }
    private fun ensureValidUrl(url: String?): String? { /* ... */ }
    override fun onCleared() { /* ... */ }

}


(Полный код существующих методов есть в предыдущих ответах)

Этап 6: Layout для редактирования профиля (fragment_edit_profile.xml)

<!-- res/layout/fragment_edit_profile.xml -->
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".ui.fragments.EditProfileFragment">

    <!-- Toolbar (Опционально, можно управлять из фрагмента) -->
    <com.google.android.material.appbar.MaterialToolbar
        android:id="@+id/toolbarEditProfile"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        app:title="Редактировать профиль"
        app:navigationIcon="@drawable/ic_arrow_back"
        app:navigationContentDescription="@string/navigate_up"
        app:menu="@menu/edit_profile_menu" <!-- Меню с кнопкой "Сохранить" -->
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <!-- Аватар -->
    <ImageView
        android:id="@+id/ivEditAvatar"
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:layout_marginTop="24dp"
        android:scaleType="centerCrop"
        android:contentDescription="Аватар пользователя"
        android:background="@drawable/avatar_border"
        app:layout_constraintTop_toBottomOf="@id/toolbarEditProfile"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:src="@drawable/a1" /> <!-- Placeholder -->

    <!-- Кнопка для смены аватара (поверх ImageView) -->
    <ImageButton
        android:id="@+id/btnChangeAvatar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/ic_edit"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:padding="8dp"
        android:contentDescription="Изменить аватар"
        app:tint="?attr/colorOnSurface"
        app:layout_constraintBottom_toBottomOf="@id/ivEditAvatar"
        app:layout_constraintEnd_toEndOf="@id/ivEditAvatar"/>

    <!-- Отображаемое имя -->
    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/tilDisplayName"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        app:layout_constraintTop_toBottomOf="@id/ivEditAvatar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/etDisplayName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Отображаемое имя"
            android:inputType="textPersonName|textCapWords"
            android:maxLines="1"/>
    </com.google.android.material.textfield.TextInputLayout>

    <!-- Email (только для отображения, не редактируется здесь) -->
     <TextView
         android:id="@+id/tvEditEmailLabel"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_marginTop="16dp"
         android:text="Email (нельзя изменить)"
         android:textAppearance="?attr/textAppearanceCaption"
         app:layout_constraintTop_toBottomOf="@id/tilDisplayName"
         app:layout_constraintStart_toStartOf="parent"/>

     <TextView
         android:id="@+id/tvEditEmailValue"
         android:layout_width="0dp"
         android:layout_height="wrap_content"
         android:layout_marginTop="4dp"
         android:textAppearance="?attr/textAppearanceBody1"
         android:textColor="?android:attr/textColorSecondary"
         app:layout_constraintTop_toBottomOf="@id/tvEditEmailLabel"
         app:layout_constraintStart_toStartOf="parent"
         app:layout_constraintEnd_toEndOf="parent"
         tools:text="user@example.com"/>

     <!-- Индикатор загрузки -->
     <ProgressBar
         android:id="@+id/editProfileProgressBar"
         style="?android:attr/progressBarStyle"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_marginTop="32dp"
         android:visibility="gone"
         app:layout_constraintTop_toBottomOf="@id/tvEditEmailValue"
         app:layout_constraintStart_toStartOf="parent"
         app:layout_constraintEnd_toEndOf="parent"
         tools:visibility="visible"/>

</androidx.constraintlayout.widget.ConstraintLayout>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Xml
IGNORE_WHEN_COPYING_END

Этап 7: Меню для fragment_edit_profile.xml (edit_profile_menu.xml)

<!-- res/menu/edit_profile_menu.xml -->
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_save_profile"
        android:title="Сохранить"
        android:icon="@drawable/ic_save" <!-- Добавьте иконку сохранения -->
        app:showAsAction="ifRoom|withText" />
</menu>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Xml
IGNORE_WHEN_COPYING_END

Продолжим с реализацией выбора аватара и самого EditProfileFragment?

Отлично, двигаемся дальше.

Этап 7: Реализация выбора/сохранения аватара (логика)

Эта логика будет в EditProfileFragment, но основана на ActivityResultLauncher.

Добавить зависимость (если еще нет):
Убедитесь, что в build.gradle (app) есть зависимость для Activity Result API:

dependencies {
    // ... другие зависимости
    implementation "androidx.activity:activity-ktx:1.8.0" // Или новее
    implementation "androidx.fragment:fragment-ktx:1.6.2" // Или новее
}


Логика в EditProfileFragment: Мы объявим ActivityResultLauncher для получения контента (изображения) и обработаем результат.

Этап 8: Обновить ProfileFragment

Отображать данные из UserEntity.

Добавить кнопку редактирования.

Загружать аватар.

package com.example.tutor.ui.fragments

import android.net.Uri // Для работы с Uri аватара
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.net.toUri // Для конвертации String path в Uri
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.navigation.fragment.findNavController // Для навигации
import com.bumptech.glide.Glide // Для загрузки аватара
import com.bumptech.glide.request.RequestOptions // Для плейсхолдера и ошибки
import com.example.tutor.R
import com.example.tutor.databinding.FragmentProfileBinding
import com.example.tutor.viewmodels.PasswordViewModel
// Firebase Auth здесь больше не нужен напрямую, получаем данные из ViewModel
// import com.google.firebase.auth.FirebaseAuth
// import com.google.firebase.auth.ktx.auth
// import com.google.firebase.ktx.Firebase
import java.io.File // Для проверки существования файла аватара

class ProfileFragment : Fragment() {

    private var _binding: FragmentProfileBinding? = null
    private val binding get() = _binding!!

    // ViewModel остается общим для активности
    private val passwordViewModel: PasswordViewModel by activityViewModels()

    // Кнопка редактирования (добавим ее в layout позже)
    // private lateinit var editProfileButton: Button

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentProfileBinding.inflate(inflater, container, false)
        Log.d("ProfileFragment", "onCreateView")
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        Log.d("ProfileFragment", "onViewCreated")

        // Находим кнопку редактирования (предполагаем, что добавили ее в XML)
        // editProfileButton = binding.btnEditProfile // Раскомментировать и добавить ID в XML

        // Наблюдаем за профилем пользователя из ViewModel
        passwordViewModel.userProfile.observe(viewLifecycleOwner) { userEntity ->
            if (userEntity != null) {
                Log.d("ProfileFragment", "Обновление UI профиля для пользователя ${userEntity.userId}")
                // Отображаем имя пользователя (если есть, иначе email)
                binding.tvProfileEmail.text = userEntity.displayName?.takeIf { it.isNotBlank() } ?: userEntity.email ?: getString(R.string.no_email_available)
                // Загружаем аватар
                loadAvatar(userEntity.avatarPath)
            } else {
                // Профиль еще не загружен или не существует
                Log.w("ProfileFragment", "UserEntity is null, отображаем плейсхолдеры.")
                binding.tvProfileEmail.text = getString(R.string.loading_data) // Или email из Firebase Auth как запасной вариант
                loadAvatar(null) // Показать плейсхолдер
            }
        }

        // Наблюдение за статистикой паролей (как и раньше)
        passwordViewModel.passwordCountsByCategory.observe(viewLifecycleOwner) { counts ->
            // ... (код отображения статистики без изменений) ...
            if (counts == null) { Log.w("ProfileFragment", "Password counts data is null."); return@observe }
            val total = counts.values.sum(); binding.tvTotalPasswords.text = total.toString()
            val categoryText = if (counts.isEmpty()) { getString(R.string.no_passwords_yet) } else { counts.entries.sortedBy { it.key }.joinToString("\n") { "${it.key}: ${it.value}" } }; binding.tvCategoryCounts.text = categoryText
            Log.d("ProfileFragment", "Статистика паролей обновлена: Всего=$total")
        }

        // Обработчик нажатия кнопки редактирования
        binding.btnEditProfile.setOnClickListener { // <- Добавить эту кнопку в XML
            Log.d("ProfileFragment", "Нажата кнопка Редактировать профиль")
            findNavController().navigate(R.id.action_profileFragment_to_editProfileFragment) // <- Добавить это действие в nav_graph
        }
    }

    // Функция загрузки аватара с плейсхолдером/ошибкой
    private fun loadAvatar(avatarPath: String?) {
        val fileUri: Uri? = avatarPath?.let { File(it).toUri() }

        Glide.with(this)
            .load(fileUri) // Загружаем Uri файла или null
            .apply(RequestOptions.circleCropTransform() // Делаем круглым
                .placeholder(R.drawable.ic_profile_placeholder) // Плейсхолдер по умолчанию
                .error(R.drawable.ic_profile_error) // Иконка при ошибке загрузки
                .skipMemoryCache(true) // Не кешировать файл в памяти Glide (он уже на диске)
                //.diskCacheStrategy(DiskCacheStrategy.NONE) // Не кешировать файл в дисковом кеше Glide
            )
            .into(binding.ivProfileAvatar) // Загружаем в ImageView
        if (avatarPath != null) {
             Log.d("ProfileFragment", "Загрузка аватара из: $avatarPath")
        } else {
             Log.d("ProfileFragment", "Аватар не установлен, показан плейсхолдер.")
        }
    }


    override fun onDestroyView() {
        super.onDestroyView()
        Log.d("ProfileFragment", "onDestroyView")
        _binding = null
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Изменения в fragment_profile.xml:

Добавьте Button для редактирования профиля:

<!-- ... (внутри ConstraintLayout или ScrollView) ... -->

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btnEditProfile"
        style="@style/Widget.MaterialComponents.Button.TextButton.Icon"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Редактировать"
        app:icon="@drawable/ic_edit"
        app:layout_constraintTop_toBottomOf="@id/profile_card" <!-- Или другое позиционирование -->
        app:layout_constraintEnd_toEndOf="@id/profile_card"
        android:layout_marginTop="16dp" />

    <!-- ... (остальные элементы) ... -->
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Xml
IGNORE_WHEN_COPYING_END

Изменения в nav_graph.xml:

Добавьте EditProfileFragment как destination.

Добавьте action от ProfileFragment к EditProfileFragment.

<!-- res/navigation/nav_graph.xml -->
    <!-- ... (другие fragment и dialog) ... -->

    <fragment
        android:id="@+id/navigation_profile"
        android:name="com.example.tutor.ui.fragments.ProfileFragment"
        android:label="@string/title_profile"
        tools:layout="@layout/fragment_profile" >
        <!-- Действие для перехода к редактированию -->
        <action
            android:id="@+id/action_profileFragment_to_editProfileFragment"
            app:destination="@id/editProfileFragment"
            app:enterAnim="@anim/slide_in_right"
            app:exitAnim="@anim/slide_out_left"
            app:popEnterAnim="@anim/slide_in_left"
            app:popExitAnim="@anim/slide_out_right" />
    </fragment>

    <!-- Новый фрагмент для редактирования -->
     <fragment
        android:id="@+id/editProfileFragment"
        android:name="com.example.tutor.ui.fragments.EditProfileFragment"
        android:label="Редактировать профиль"
        tools:layout="@layout/fragment_edit_profile" />

    <!-- ... (другие fragment и dialog) ... -->
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Xml
IGNORE_WHEN_COPYING_END

(Не забудьте добавить нужные <string> и <drawable>)

Этап 9: Реализовать EditProfileFragment.kt

package com.example.tutor.ui.fragments

import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.net.toUri
import androidx.core.view.isVisible // Для ProgressBar
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.navigation.fragment.findNavController
import com.bumptech.glide.Glide
import com.bumptech.glide.request.RequestOptions
import com.example.tutor.R
import com.example.tutor.databinding.FragmentEditProfileBinding
import com.example.tutor.db.UserEntity
import com.example.tutor.viewmodels.PasswordViewModel
import java.io.File

class EditProfileFragment : Fragment() {

    private var _binding: FragmentEditProfileBinding? = null
    private val binding get() = _binding!!
    private val passwordViewModel: PasswordViewModel by activityViewModels()

    private var currentUserProfile: UserEntity? = null
    private var selectedAvatarUri: Uri? = null // Uri выбранного, но еще не сохраненного аватара

    // ActivityResultLauncher для выбора изображения
    private lateinit var pickMediaLauncher: ActivityResultLauncher<PickVisualMediaRequest>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Регистрируем лаунчер для выбора изображения
        pickMediaLauncher = registerForActivityResult(ActivityResultContracts.PickVisualMedia()) { uri ->
            if (uri != null) {
                Log.d("EditProfileFragment", "Выбрано изображение: $uri")
                selectedAvatarUri = uri
                // Отображаем выбранное изображение немедленно
                loadAvatarPreview(uri)
            } else {
                Log.d("EditProfileFragment", "Выбор изображения отменен.")
            }
        }
    }


    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentEditProfileBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupToolbar()

        // Наблюдаем за профилем, чтобы предзаполнить поля
        passwordViewModel.userProfile.observe(viewLifecycleOwner) { user ->
            if (user != null && currentUserProfile == null) { // Предзаполняем только один раз
                currentUserProfile = user
                binding.etDisplayName.setText(user.displayName ?: "")
                binding.tvEditEmailValue.text = user.email ?: "" // Отображаем email
                selectedAvatarUri = null // Сбрасываем выбранный URI при загрузке профиля
                loadAvatarPreview(user.avatarPath?.let { File(it).toUri() }) // Загружаем текущий аватар
            } else if (user != null) {
                 // Обновляем только email на случай его изменения в Firebase
                 currentUserProfile = user // Обновляем локальную копию
                 binding.tvEditEmailValue.text = user.email ?: ""
                 // Не перезагружаем имя и аватар, если пользователь их уже менял на этом экране
            }
        }

        // Обработчик клика для смены аватара
        binding.btnChangeAvatar.setOnClickListener {
            // Запускаем выбор только изображений
            pickMediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
        }
        binding.ivEditAvatar.setOnClickListener { // Клик по самому аватару тоже запускает выбор
             pickMediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
        }
    }

    private fun setupToolbar() {
        binding.toolbarEditProfile.setNavigationOnClickListener {
            findNavController().navigateUp() // Возвращаемся назад
        }
        binding.toolbarEditProfile.setOnMenuItemClickListener { menuItem ->
            when (menuItem.itemId) {
                R.id.action_save_profile -> {
                    saveProfileChanges()
                    true
                }
                else -> false
            }
        }
    }

    private fun loadAvatarPreview(uri: Uri?) {
         Glide.with(this)
            .load(uri)
            .apply(RequestOptions.circleCropTransform()
                .placeholder(R.drawable.ic_profile_placeholder)
                .error(R.drawable.ic_profile_error)
                // Не используем skipMemoryCache/diskCacheStrategy(NONE) для превью,
                // чтобы Glide мог кешировать выбранные, но не сохраненные изображения
            )
            .into(binding.ivEditAvatar)
    }

    private fun saveProfileChanges() {
        val newDisplayName = binding.etDisplayName.text.toString().trim().takeIf { it.isNotEmpty() } // null если пустое
        val avatarToSaveUri = selectedAvatarUri // Uri нового аватара или null

        // Можно добавить проверку, изменилось ли что-то вообще

        // Показываем ProgressBar
        binding.editProfileProgressBar.isVisible = true
        // Блокируем кнопку сохранения? (Опционально)
        // binding.toolbarEditProfile.menu.findItem(R.id.action_save_profile)?.isEnabled = false

        Log.d("EditProfileFragment", "Сохранение изменений: Имя='$newDisplayName', Аватар URI='$avatarToSaveUri'")

        // Вызываем метод ViewModel для сохранения
        passwordViewModel.updateUserProfile(newDisplayName, avatarToSaveUri)

        // ViewModel обновит LiveData, что вызовет обновление в ProfileFragment.
        // Здесь просто возвращаемся назад после инициирования сохранения.
        // Можно дождаться завершения операции в ViewModel, если нужна обратная связь здесь.

        // Небольшая задержка для визуального эффекта (опционально)
        view?.postDelayed({
            binding.editProfileProgressBar.isVisible = false
             Toast.makeText(context, "Профиль сохранен", Toast.LENGTH_SHORT).show()
            findNavController().navigateUp() // Возвращаемся на экран профиля
        }, 500) // Задержка 0.5 сек
    }


    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Этап 10: Создание UserEntity при первом входе/регистрации

Это нужно делать в LoginActivity и RegisterActivity после успешного входа/регистрации, перед переходом в MainActivity.

Изменения в LoginActivity.kt:

// LoginActivity.kt
// ... (импорты как раньше, включая AppDatabase, lifecycleScope, ...)
import com.example.tutor.db.UserEntity // Импорт UserEntity

class LoginActivity : FragmentActivity() {
    // ... (auth, binding, sharedPreferences, securityLogDao) ...
    private lateinit var userDao: com.example.tutor.db.UserDao // Добавляем UserDao

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // ... (инициализация binding, auth, prefs, securityLogDao) ...
        userDao = AppDatabase.getDatabase(this).userDao() // Инициализация UserDao
        // ... (остальное в onCreate) ...
    }

    private fun loginUser(email: String, password: String) {
        // ... (progressBar, disable button) ...
        auth.signInWithEmailAndPassword(email, password).addOnCompleteListener(this) { task ->
            // ... (progressBar, enable button, timestamp) ...
            if (task.isSuccessful) {
                Log.d("LoginActivity", "Успешный вход в систему")
                // ... (логирование безопасности) ...
                savePreferences(email)

                // --- !!! СОЗДАНИЕ/ОБНОВЛЕНИЕ ПРОФИЛЯ ПОЛЬЗОВАТЕЛЯ В ROOM !!! ---
                val firebaseUser = auth.currentUser
                if (firebaseUser != null) {
                    lifecycleScope.launch(Dispatchers.IO) {
                        val existingUser = userDao.getUserByIdOnce(firebaseUser.uid)
                        if (existingUser == null) {
                            // Создаем, если нет
                             val newUser = UserEntity(
                                userId = firebaseUser.uid,
                                displayName = firebaseUser.displayName,
                                email = firebaseUser.email,
                                avatarPath = null
                            )
                            userDao.insertOrUpdateUser(newUser)
                            Log.i("LoginActivity", "Создан профиль Room для ${firebaseUser.uid}")
                        } else {
                            // Опционально: Обновляем email/имя, если они изменились в Firebase
                            if (existingUser.email != firebaseUser.email || existingUser.displayName != firebaseUser.displayName) {
                                 val updatedUser = existingUser.copy(
                                     email = firebaseUser.email,
                                     displayName = firebaseUser.displayName
                                 )
                                 userDao.insertOrUpdateUser(updatedUser)
                                 Log.i("LoginActivity", "Обновлен профиль Room для ${firebaseUser.uid}")
                            } else {
                                 Log.d("LoginActivity", "Профиль Room для ${firebaseUser.uid} уже существует и актуален.")
                            }
                        }
                    }
                } else {
                     Log.e("LoginActivity", "FirebaseUser null после успешного входа!")
                }
                // --- !!! КОНЕЦ СОЗДАНИЯ/ОБНОВЛЕНИЯ ПРОФИЛЯ !!! ---

                // Переход в MainActivity
                val intent = Intent(this, MainActivity::class.java)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                startActivity(intent)
                finish()
            } else {
                // ... (обработка ошибок, логирование безопасности) ...
            }
        }
    }
    // ... (остальной код LoginActivity) ...
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Изменения в RegisterActivity.kt: (Аналогично LoginActivity)

// RegisterActivity.kt
// ... (импорты как раньше, включая AppDatabase, lifecycleScope, ...)
import com.example.tutor.db.UserEntity // Импорт UserEntity

class RegisterActivity : FragmentActivity() {
     // ... (auth, binding, securityLogDao) ...
     private lateinit var userDao: com.example.tutor.db.UserDao // Добавляем UserDao

     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
         // ... (инициализация binding, auth, securityLogDao) ...
         userDao = AppDatabase.getDatabase(this).userDao() // Инициализация UserDao
         // ... (остальное в onCreate) ...
     }

    private fun registerUser(email: String, password: String) {
        // ... (progressBar, disable button) ...
        auth.createUserWithEmailAndPassword(email, password).addOnCompleteListener(this) { task ->
            // ... (progressBar, enable button, timestamp) ...
            if (task.isSuccessful) {
                Log.d("RegisterActivity", "Пользователь успешно создан")
                // ... (логирование безопасности) ...

                // --- !!! СОЗДАНИЕ ПРОФИЛЯ ПОЛЬЗОВАТЕЛЯ В ROOM !!! ---
                 val firebaseUser = auth.currentUser
                 if (firebaseUser != null) {
                     lifecycleScope.launch(Dispatchers.IO) {
                         // При регистрации профиля точно не должно быть, просто создаем
                          val newUser = UserEntity(
                             userId = firebaseUser.uid,
                             displayName = firebaseUser.displayName, // Обычно null сразу после регистрации
                             email = firebaseUser.email,
                             avatarPath = null
                         )
                         userDao.insertOrUpdateUser(newUser)
                         Log.i("RegisterActivity", "Создан профиль Room для нового пользователя ${firebaseUser.uid}")
                     }
                 } else {
                      Log.e("RegisterActivity", "FirebaseUser null после успешной регистрации!")
                 }
                // --- !!! КОНЕЦ СОЗДАНИЯ ПРОФИЛЯ !!! ---

                // Переход в MainActivity
                val intent = Intent(this, MainActivity::class.java)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                startActivity(intent)
                finish()
            } else {
                 // ... (обработка ошибок, логирование безопасности) ...
            }
        }
    }
     // ... (остальной код RegisterActivity) ...
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Kotlin
IGNORE_WHEN_COPYING_END

Теперь у вас должна быть реализована функция просмотра и редактирования профиля пользователя с аватаром, хранящимся локально. Не забудьте добавить все необходимые ресурсы (строки, иконки, цвета, анимации) и проверить зависимости Gradle.